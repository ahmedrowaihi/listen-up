// .eslintrc.cjs
module.exports = {
    root: true,
    plugins: ['@typescript-eslint', 'import', 'prettier'],
    extends: [
      'airbnb-typescript/base',
      'prettier',
      'plugin:@typescript-eslint/recommended',
      'plugin:import/typescript',
    ],
    parser: '@typescript-eslint/parser',
    parserOptions: {
      project: './tsconfig.eslint.json',
      extraFileExtensions: ['.json','.mjs', '.cjs'],
      
    },
  };
  

// .npmignore
node_modules/
src/


// .pretterrc
{
  "printWidth": 180,
  "useTabs": true,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "jsxSingleQuote": false,
  "arrowParens": "always",
  "proseWrap": "never",
  "htmlWhitespaceSensitivity": "strict",
  "endOfLine": "crlf"
}

// babel.config.json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": true
        }
      }
    ]
  ]
}

// jest.config.ts
import type {Config} from 'jest';

const config: Config = {
  verbose: true,
  transform: {
    '^.+\\.ts?$': 'ts-jest',
    '^.+\\.tsx$': 'ts-jest',
    '^.+\\.js$': 'babel-jest',
    "^.+\\.jsx?$": "babel-jest"
  },
  transformIgnorePatterns: ['<rootDir>/node_modules/'],
  testEnvironment: 'node',
  collectCoverage: true,
  coverageReporters: ['text', 'lcov'],
  coverageDirectory: 'coverage',
  testMatch: ['**/__tests__/**/*.test.ts'],
  preset: 'ts-jest/presets/js-with-ts',
};

export default config;

// package.json
{
  "name": "@ahmedrowaihi/listen-up",
  "description": "A simple HTTP server that listens on a port and prints out the request body to the console, with cloudflared tunneling support.",
  "version": "2.0.2",
  "main": "index.js",
  "type": "module",
  "private": false,
  "author": "Ahmed Rowaihi <ahmedrowaihi@gmail.com>",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/ahmedrowaihi/listen-up.git"
  },
  "bugs": {
    "url": "https://github.com/ahmedrowaihi/listen-up/issues"
  },
  "homepage": "https://github.com/ahmedrowaihi/listen-up",
  "keywords": [
    "http",
    "server",
    "listen",
    "cloudflare",
    "cloudflared",
    "tunnel",
    "logging"
  ],
  "bin": {
    "listen-up": "./dist/index.js"
  },
  "scripts": {
    "test": "jest",
    "prestart": "tsc",
    "start": "node ./dist/index.js",
    "build": "tsc",
    "lint": "eslint . && prettier ."
  },
  "publishConfig": {
    "access": "public"
  },
  "license": "MIT",
  "dependencies": {
    "chalk": "^5.3.0",
    "cloudflared": "^0.4.0",
    "express": "^4.18.2",
    "morgan-body": "^2.6.9",
    "nanospinner": "^1.1.0",
    "readline-sync": "^1.4.10",
    "yargs": "^17.7.2",
    "yargs-parser": "^21.1.1"
  },
  "release-it": {
    "git": {
      "tagName": "${version}"
    },
    "npm": {
      "publish": true
    }
  },
  "devDependencies": {
    "@babel/core": "^7.22.10",
    "@babel/preset-env": "^7.22.10",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.3",
    "@types/yargs-parser": "^21.0.0",
    "@typescript-eslint/eslint-plugin": "^5.13.0",
    "@typescript-eslint/parser": "^5.0.0",
    "eslint": "^8.2.0",
    "eslint-config-airbnb-base": "^15.0.0",
    "eslint-config-airbnb-typescript": "^17.1.0",
    "eslint-config-prettier": "^8.9.0",
    "eslint-plugin-import": "^2.25.2",
    "eslint-plugin-prettier": "^5.0.0",
    "jest": "^29.6.2",
    "prettier": "^3.0.0",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "typescript": "^5.1.6"
  }
}


// src/api.ts
import chalk from 'chalk';
import type { Request, Response } from 'express';

export function handleRequest(req: Request, res: Response) {
	try {
		console.log(chalk.blue(`Query params: ${JSON.stringify(req.query)}`));
		res.send(`Received ${req.method} request for ${req.originalUrl}`);
	} catch (error) {
		res.status(500).send(error);
	}
}


// src/cloudflared-tunnel.ts
import chalk from "chalk";
import { bin, install, tunnel } from "cloudflared";
import { createSpinner } from "nanospinner";
import { spawnSync } from "node:child_process";
import fs from "node:fs";
import os from "node:os";
import { resolve } from "node:path";
import readlineSync from "readline-sync";
import { TUNNELNAME } from "./constants";
import type { Domain, Tunnel } from "./types";

export async function setup() {
  if (fs.existsSync(bin))
    return console.log(chalk.blue("Cloudflared binary already installed."));
  const spinner = createSpinner("Installing cloudflared binary...").start();
  await install(bin)
    .then(() =>
      spinner.success({
        text: "Installed cloudflared binary.",
      })
    )
    .catch((err) => {
      spinner.error({
        text: "Failed to install cloudflared binary.",
      });
      console.log(chalk.red(err));
      process.exit(1);
    });
}

export async function cloudflaredLogin() {
  return spawnSync(bin, ["login"], { stdio: "inherit" });
}

export function createTunnel() {
  const spinner = createSpinner("Creating tunnel...").start();
  const result = spawnSync(bin, ["tunnel", "create", TUNNELNAME], {
    stdio: "inherit",
  });
  if (result.status === 0)
    spinner.success({
      text: "Created tunnel.",
    });
  else throw new Error("Failed to create tunnel.");
}

export function routeDnsToTunnel(domain: Domain) {
  let DOMAIN =
    domain ||
    readlineSync.question(
      "Enter your authorized domain (e.g. example.com): \n"
    );
  DOMAIN = DOMAIN.replace(/^(https?:\/\/)?(www\.)?/i, "").replace(/\/$/, ""); // remove http(s)://, www. and trailing slash
  const spinner = createSpinner("Routing DNS to tunnel...").start();
  const result = spawnSync(
    bin,
    ["tunnel", "route", "dns", "-f", TUNNELNAME, `${TUNNELNAME}.${DOMAIN}`],
    {
      stdio: "inherit",
    }
  );
  if (result.status === 0)
    spinner.success({
      text: "Routed DNS to tunnel.",
    });
  else {
    spinner.error({
      text: "Failed to route DNS to tunnel.",
    });
    console.log(chalk.red(result.stderr));
    process.exit(1);
  }
}

export async function checkListenUpTunnelExist(domain: Domain) {
  console.log(chalk.blue("Checking for existing tunnels..."));
  const result = spawnSync(bin, ["tunnel", "list"]);
  if (result.status === 0) {
    const lines = result.stdout.toString().trim().split("\n");
    const tunnelDetails = {} as Tunnel;
    const tunnelExist = lines.slice(2).some((line) => {
      const [id, name] = line.trim().split(/\s+/);
      if (name === TUNNELNAME) {
        tunnelDetails.id = id;
        tunnelDetails.name = name;
        return true;
      }
    });
    if (!tunnelExist) createTunnel();
    console.log(chalk.green("Found existing tunnel."));
    routeDnsToTunnel(domain);
    return tunnelDetails;
  } else throw new Error("Failed to list tunnels");
}

export async function privateStartTunnel(_tunnel: Tunnel, port: number) {
  const { url, connections, child, stop } = tunnel({
    "--credentials-file": resolve(
      os.homedir(),
      ".cloudflared",
      `${_tunnel.id}.json`
    ),
    "--url": `http://localhost:${port}`,
    tunnel: TUNNELNAME,
  });

  console.log(`Secure tunnel URL: ${await url}`);
  console.log("Connections Ready!", await Promise.all(connections));
  process.stdin.setRawMode(true);
  process.stdin.resume();
  process.stdin.on("data", async (data) =>
    data.toString().toLocaleLowerCase() === "q"
      ? stop()
      : console.log("Press Q to quit")
  );
  child.on("exit", (code) => {
    console.log("tunnel process exited with code", code);
    process.exit();
  });
}

export async function startTunnel({ d: domain, p: port }) {
  await setup();
  await cloudflaredLogin();
  const privateTunnel = await checkListenUpTunnelExist(domain);
  console.log(chalk.blue("Starting tunnel..."));
  privateStartTunnel(privateTunnel, port);
}


// src/constants.ts
export const TUNNELNAME = "listen-up";


// src/index.ts
#!/usr/bin/env node
import yargsParser from "yargs-parser";
import chalk from "chalk";
import { startTunnel } from "./cloudflared-tunnel";
import { runServer } from "./log-server";

const yargsParserOptions = {
  alias: { p: "port", d: "domain" },
  describe: {
    p: "Port to listen on",
    d: "Domain to route to the SSH tunnel (e.g. example.com)",
  },
  default: {
    p: 80,
    d: "",
  },
};

const options = yargsParser(process.argv.slice(2), yargsParserOptions) as unknown as { p: number; d: string };

options.p = !isNaN(options.p) ? options.p : 80;

runServer(options, () => {
  console.log(chalk.blue(`Server listening on port localhost:${options.p}`));
  if (options.d) startTunnel(options);
});


// src/log-server.ts
import express from "express";
import morgan from "morgan-body";
import { handleRequest } from "./api";

export function runServer({ p }, callback: () => void) {
  console.log("Starting server...");
  const app = express();
  morgan(app, {
    logReqUserAgent: false,
    logRequestBody: true,
    logResponseBody: false,
    maxBodyLength: 10000,
  });
  app.use(express.json());
  app.use(express.urlencoded({ extended: true }));
  app.all("*", handleRequest);
  app.listen(p, callback);
}


// src/types.ts
export type Domain = string;
export type Tunnel = {
  id: string;
  name: string;
};


// tsconfig.eslint.json
{
    "extends": "./tsconfig.json",
    "include": ["./**/*.ts", "./**/*.js", "./.*.js", "./.*.cjs"]
  }

// tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "es2020",
    "moduleResolution": "Node",
    "baseUrl": "./",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true ,
    "noImplicitAny": false,
    "skipLibCheck": true,
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}


// __tests__/api.test.ts
import { handleRequest } from '../src/api';
import { Request, Response } from 'express';

describe('handleRequest', () => {
  it('should handle request and send response', () => {
    const req = {
      method: 'GET',
      originalUrl: '/test',
      query: { key: 'value' },
    } as unknown as Request;

    const res = {
      send: jest.fn(),
      status: jest.fn().mockReturnThis(),
    } as unknown as Response;

    handleRequest(req, res);

    expect(res.send).toHaveBeenCalledWith('Received GET request for /test');
  });

  // Additional tests for error handling and other scenarios
});


// __tests__/cloudflared-tunnel.test.ts
import { setup, startTunnel } from '../src/cloudflared-tunnel';

describe('Cloudflared Tunnel', () => {
  it('should setup without errors', async () => {
    await expect(setup()).resolves.not.toThrow();
  });

  it('should start tunnel without errors', async () => {
    await expect(startTunnel({ d: 'domain', p: 80 })).resolves.not.toThrow();
  });

  // Additional tests for other functions and scenarios
});


// __tests__/log-server.test.ts
import { runServer } from '../src/log-server';

describe('Log Server', () => {
  it('should start the server without errors', () => {
    const callback = jest.fn();
    runServer({ p: 80 }, callback);

    expect(callback).toHaveBeenCalled();
  });

  // Additional tests for request handling and other scenarios
});
